****** Class Locale ******

java.lang.Object
java.util.Locale

Реализуемые интерфейсы: Serializable,
                        Cloneable
-------------------------------------------------------------------------------------------
public final class Locale
                   extends Object
                   implements Cloneable, Serializable
-------------------------------------------------------------------------------------------
См. так же: Locale.Builder, ResourceBundle, Format, NumberFormat, Collator, Serialized Form
-------------------------------------------------------------------------------------------

Объект Locale представляет определенный географический, политический или культурный регион.
Операция, для выполнения которой требуется локаль, называется зависимой от локали и использует
локаль для настройки информации для пользователя.

Например, отображение числа зависит от региональных настроек — число должно быть отформатировано
в соответствии с обычаями и соглашениями родной страны, региона или культуры пользователя.

Класс Locale реализует IETF BCP 47, который состоит из RFC 4647 «Сопоставление языковых тегов» и
RFC 5646 «Теги для идентификации языков» с поддержкой LDML (UTS № 35, «Язык разметки данных локали
Unicode»), совместимый с BCP 47. расширения для обмена данными локали.

Объект Locale логически состоит из полей, описанных ниже.

*** ЯЗЫК ***

Код языка ISO 639 alpha-2 или alpha-3 или зарегистрированные языковые вложенные теги до 8 букв
(для будущих улучшений). Когда язык имеет код альфа-2 и код альфа-3, необходимо использовать
код альфа-2. Вы можете найти полный список допустимых языковых кодов в реестре языковых подтегов
IANA (ищите «Тип: язык»). Поле языка нечувствительно к регистру, но Locale всегда канонизирует
нижний регистр.

Правильно сформированные языковые значения имеют форму [a-zA-Z]{2,8}. Обратите внимание, что это
не полная версия языка BCP47, поскольку она исключает extlang. Они не нужны, поскольку их заменяют
современные трехбуквенные языковые коды.

Пример: «en» (английский), «ja» (японский), «kok» (конкани).

*** Скрипт (сценарий) ***

Код сценария альфа-4 ISO 15924. Вы можете найти полный список допустимых кодов сценариев в реестре
языковых подтегов IANA (ищите «Type: script»). Поле script нечувствительно к регистру, но Locale
всегда канонизируется до регистра заглавий (первая буква в верхнем регистре, а остальные буквы в
нижнем регистре).

Правильно сформированные значения сценария имеют форму [a-zA-Z]{4}.

Пример: «Latn» (латиница), «Cyrl» (кириллица).

*** Страна (регион) ****

Код страны ISO 3166 alpha-2 или числовой код зоны UN M.49-3. Вы можете найти полный список допустимых
кодов стран и регионов в реестре языковых субтэгов IANA (ищите «Тип: регион»). Поле страны (региона)
нечувствительно к регистру, но Locale всегда канонизирует верхний регистр.

Правильно сформированные значения страны/региона имеют вид [a-zA-Z]{2} | [0-9]{3}

Пример: «US» (США), «FR» (Франция), «029» (Карибский бассейн).

*** Вариант ***

Любое произвольное значение, используемое для обозначения варианта Locale. Там, где имеется два или
более вариантов значений, каждое из которых указывает свою собственную семантику, эти значения должны
быть упорядочены по важности, начиная с самого важного и отделяемого символом подчеркивания ('_').

Поле варианта чувствительно к регистру.

Примечание. IETF BCP 47 накладывает синтаксические ограничения на вариантные вложенные теги. Кроме
того, вложенные теги BCP 47 строго используются для обозначения дополнительных вариантов, определяющих
язык или его диалекты, которые не охватываются какими-либо комбинациями вложенных тегов языка, сценария
и региона. Вы можете найти полный список допустимых кодов вариантов в реестре языковых вложенных тегов
IANA (ищите «Тип: вариант»).

Однако поле варианта в Locale исторически использовалось для любых вариантов, а не только для языковых
вариантов. Например, некоторые поддерживаемые варианты, доступные в средах выполнения Java SE, указывают
на альтернативные культурные особенности поведения, такие как тип календаря или числовой сценарий.
В BCP 47 этот вид информации, которая не идентифицирует язык, поддерживается вложенными тегами расширения
или вложенными тегами частного использования.

Правильно сформированные значения вариантов имеют форму SUBTAG (('_'|'-') SUBTAG)*,
где SUBTAG = [0-9][0-9a-zA-Z]{3} | [0-9a-zA-Z]{5,8}.
(Примечание: BCP 47 использует только дефис («-») в качестве разделителя, это более мягко).

Пример: "polyton" (политонический греческий), "POSIX"

*** Расширения ***

Сопоставление односимвольных ключей со строковыми значениями, указывающее расширения помимо идентификации
языка. Расширения в Locale реализуют семантику и синтаксис вложенных тегов расширения BCP 47 и вложенных
тегов частного использования. Расширения нечувствительны к регистру, но Locale канонизирует все ключи и
значения расширений в нижнем регистре.

Обратите внимание, что расширения не могут иметь пустых значений.

Правильно сформированные ключи — это отдельные символы из набора [0-9a-zA-Z]. Правильно сформированные
значения имеют вид ПОДТЕГ ('-' ПОДТЕГ)*, где для ключа 'x' ПОДТЕГ = [0-9a-zA-Z]{1,8}, а для остальных
ключей ПОДТЕГ = [0-9a-zA -Z]{2,8} (то есть 'x' разрешает односимвольные вложенные теги).

Пример: key="u"/value="ca-japanese" (японский календарь), key="x"/value="java-1-7"

Примечание. Хотя BCP 47 требует, чтобы значения полей были зарегистрированы в реестре языковых вложенных
            тегов IANA, класс Locale не предоставляет никаких функций проверки. Построитель только проверяет,
            удовлетворяет ли отдельное поле синтаксическому требованию (правильно ли оно сформировано), но
            не проверяет само значение. Дополнительные сведения см. в разделе Locale.Builder.

*** Unicode locale /языковое расширение ***

UTS # 35, «Язык разметки данных локали Unicode» определяет необязательные атрибуты и ключевые слова
для переопределения или уточнения поведения по умолчанию, связанного с локалью. Ключевое слово
представлено парой ключ и тип.

Например, «nu-thai» указывает, что для форматирования чисел следует использовать тайские местные
цифры (значение: «thai») (ключ: «nu»).

Ключевые слова сопоставляются со значением расширения BCP 47 с помощью ключа расширения «u»
(UNICODE_LOCALE_EXTENSION). Приведенный выше пример «nu-thai» становится расширением «u-nu-thai».

Таким образом, когда объект Locale содержит атрибуты локали и ключевые слова Unicode,
getExtension(UNICODE_LOCALE_EXTENSION) вернет строку, представляющую эту информацию, например,
"nu-thai".

Класс Locale также предоставляет функции getUnicodeLocaleAttributes(), getUnicodeLocaleKeys() и
getUnicodeLocaleType(java.lang.String), которые позволяют напрямую обращаться к атрибутам локали
Unicode и парам ключ/тип. При представлении в виде строки расширение локали Unicode перечисляет
атрибуты в алфавитном порядке, за которыми следуют последовательности ключей/типов с ключами,
перечисленными в алфавитном порядке (порядок вложенных тегов, составляющих тип ключа, фиксируется
при определении типа)

Правильно сформированный ключ локали имеет вид [0-9a-zA-Z]{2}. Правильно сформированный тип локали
имеет форму "" | [0-9a-zA-Z]{3,8} ('-' [0-9a-zA-Z]{3,8})* (может быть пустым или набором вложенных
тегов 3-8 букв в длина).

Правильно сформированный атрибут локали имеет форму [0-9a-zA-Z]{3,8} (это один вложенный тег с той
же формой, что и вложенный тег типа локали).

Расширение языкового стандарта Unicode задает необязательное поведение в службах, зависящих от языкового
стандарта. Несмотря на то, что спецификация LDML определяет различные ключи и значения, реальные
реализации служб, чувствительных к локали, в среде выполнения Java могут не поддерживать какие-либо
конкретные атрибуты локали Unicode или пары ключ/тип.

*** Создание локали ***

Существует несколько различных способов создания объекта Locale:

1. Строитель (Builder) - Используя Locale.Builder, вы можете создать объект Locale, соответствующий
                         синтаксису BCP 47.

2. Конструкторы - Класс Locale предоставляет три конструктора:
    - Locale(String language)
    - Locale(String language, String country)
    - Locale(String language, String country, String variant)

Эти конструкторы позволяют вам создать объект Locale с языком, страной и вариантом, но вы не можете
указать сценарий или расширения.

3. Заводские методы (Factory Methods) - Метод forLanguageTag(java.lang.String) создает объект Locale
                                        для правильно сформированного языкового тега BCP 47.

4. Константы локали - Класс Locale предоставляет ряд удобных констант, которые можно использовать для
                      создания объектов Locale для часто используемых локалей. Например, следующий код
                      создает объект Locale для США: Locale.US

*** Соответствие локали ***

Если приложение или система интернационализированы и предоставляют локализованные ресурсы для нескольких
локалей, иногда требуется найти одну или несколько локалей (или языковых тегов), которые соответствуют
конкретным предпочтениям каждого пользователя. Обратите внимание, что термин «тег языка» используется
взаимозаменяемо с «локалью» в этой документации по сопоставлению локали.

Для сопоставления предпочтительных локалей пользователя с набором языковых тегов RFC 4647 «Сопоставление
языковых тегов» определяет два механизма: фильтрацию и поиск. Фильтрация используется для получения всех
совпадающих локалей, а поиск — для выбора наиболее подходящей локали. Сопоставление выполняется без учета
регистра. Эти механизмы сопоставления описаны в следующих разделах.

Предпочтение пользователя называется списком языковых приоритетов и выражается в виде списка языковых
диапазонов. Синтаксически существует два типа языковых диапазонов: базовый и расширенный. Дополнительные
сведения см. в разделе Locale.LanguageRange.

*** Фильтрация ***

Операция фильтрации возвращает все совпадающие языковые теги. Он определен в RFC 4647 следующим образом:
«При фильтрации каждый языковой диапазон представляет наименее определенный языковой тег (то есть языковой
тег с наименьшим количеством вложенных тегов), который является допустимым соответствием. Все языковые
теги в соответствующем наборе тегов будет иметь такое же или большее количество вложенных тегов, чем
языковой диапазон. Каждый вложенный тег без подстановочных знаков в языковом диапазоне будет отображаться
в каждом из соответствующих языковых тегов».

Существует два типа фильтрации: фильтрация базовых языковых диапазонов (называемая «базовая фильтрация») и
фильтрация расширенных языковых диапазонов (называемая «расширенная фильтрация»). Они могут возвращать
разные результаты в зависимости от того, какие языковые диапазоны включены в данный список языковых
приоритетов.

Locale.FilteringMode — это параметр, указывающий, как должна выполняться фильтрация.

*** Поиск локали ***

Операция поиска возвращает наиболее подходящие языковые теги. Он определен в RFC 4647 следующим образом:
«В отличие от фильтрации, каждый языковой диапазон представляет наиболее конкретный тег, который является
допустимым соответствием. Первый найденный соответствующий тег в соответствии с приоритетом пользователя
считается ближайшим соответствием и является элементом вернулся».

Например, если список языковых приоритетов состоит из двух языковых диапазонов, «zh-Hant-TW» и «en-US»,
в порядке приоритета, метод поиска последовательно ищет языковые теги ниже, чтобы найти наиболее подходящий
языковой тег.

    1. zh-Hant-TW
    2. zh-Hant
    3. zh
    4. en-US
    5. en

Если есть языковой тег, который полностью соответствует указанному выше языковому диапазону, возвращается
языковой тег.

«*» — это специальный языковой диапазон, который игнорируется при поиске.

Если несколько языковых тегов совпадают в результате вложенного тега '*', включенного в языковой диапазон,
первый совпадающий языковой тег, возвращенный Iterator над набором языковых тегов, рассматривается как
наиболее подходящий.

*** Использование локали ***

После того, как вы создали Locale, вы можете запросить у него информацию о себе. Используйте getCountry
для получения кода страны (или региона) и getLanguage для получения кода языка. Вы можете использовать
getDisplayCountry, чтобы получить название страны, подходящее для отображения пользователю. Точно так же
вы можете использовать getDisplayLanguage, чтобы получить имя языка, подходящего для отображения пользователю.

Интересно, что методы getDisplayXXX сами по себе чувствительны к локали и имеют две версии:
одна использует локаль DISPLAY по умолчанию, а другая использует локаль, указанную в качестве аргумента.

Платформа Java предоставляет ряд классов, которые выполняют операции, зависящие от региональных настроек.
Например, класс NumberFormat форматирует числа, валюту и проценты с учетом региональных настроек. Такие классы,
как NumberFormat, имеют несколько удобных методов для создания объекта по умолчанию этого типа. Например,
класс NumberFormat предоставляет эти три удобных метода для создания объекта NumberFormat по умолчанию:

*****************************************************************************************************************
     NumberFormat.getInstance()
     NumberFormat.getCurrencyInstance()
     NumberFormat.getPercentInstance()
*****************************************************************************************************************

Каждый из этих методов имеет два варианта; один с явной локалью и один без; последний использует локаль
FORMAT по умолчанию:

*****************************************************************************************************************
          NumberFormat.getInstance(myLocale)
          NumberFormat.getCurrencyInstance(myLocale)
          NumberFormat.getPercentInstance(myLocale)
*****************************************************************************************************************

Locale — это механизм для определения типа объекта (NumberFormat), который вы хотели бы получить.
Locale — это всего лишь механизм для идентификации объектов, а не контейнер для самих объектов.

*** Совместимость ***

Чтобы поддерживать совместимость с существующим использованием, конструкторы Locale сохраняют свое поведение
до версии Java Runtime Environment 1.7. То же самое в значительной степени верно для метода toString. Таким
образом, объекты Locale можно продолжать использовать как раньше. В частности, клиенты, которые анализируют
вывод toString в поля языка, страны и варианта, могут продолжать делать это (хотя это настоятельно не
рекомендуется), хотя варианты полей будут содержать дополнительную информацию, если присутствует сценарий или
расширения.

Кроме того, BCP 47 накладывает синтаксические ограничения, которые не налагаются конструкторами Locale.
Это означает, что преобразование между некоторыми локалями и языковыми тегами BCP 47 невозможно без потери
информации.

Таким образом, toLanguageTag не может представлять состояние локалей, язык, страна или вариант которых не
соответствуют BCP 47.

Из-за этих проблем клиентам рекомендуется отказаться от создания несоответствующих локалей и вместо этого
использовать API forLanguageTag и Locale.Builder. Клиенты, которым требуется строковое представление полной
локали, могут всегда полагаться на toLanguageTag для этой цели.

*** Особые случаи ***

По соображениям совместимости два несоответствующих языковых стандарта рассматриваются как особые случаи.
Это ja_JP_JP и th_TH_TH. Они неправильно сформированы в BCP 47, поскольку варианты слишком короткие. Чтобы
облегчить переход на BCP 47, они проходят специальную обработку во время создания. Эти два случая (и только
эти) заставляют конструктор генерировать расширение, все остальные значения ведут себя точно так же, как и
до Java 7.

Java использовала ja_JP_JP для представления японского языка, используемого в Японии, вместе с японским
имперским календарем. Теперь это можно представить с помощью расширения локали Unicode, указав ключ локали
Unicode ca (для «календаря») и тип japanese. Когда конструктор Locale вызывается с аргументами "ja", "JP",
"JP", автоматически добавляется расширение "u-ca-japanese".

Java использовала th_TH_TH для представления тайского языка, используемого в Таиланде, вместе с тайскими
цифрами. Теперь это также можно представить с помощью расширения локали Unicode, указав ключ локали Unicode nu
(для «числа») и значение thai. При вызове конструктора Locale с аргументами "th", "TH", "TH" автоматически
добавляется расширение "u-nu-thai".

*** Сериализация ***

Во время сериализации writeObject записывает в выходной поток все поля, включая расширения.

Во время десериализации readResolve добавляет расширения, как описано в разделе «Особые случаи», только для
двух случаев th_TH_TH и ja_JP_JP.

*** Устаревшие языковые коды ***

Конструктор Locale всегда преобразовывал коды трех языков в их более ранние, устаревшие формы:
он сопоставляется с iw, yi сопоставляется с ji, а id сопоставляется с in. Это по-прежнему имеет
место, чтобы не нарушать обратную совместимость.

API, добавленные в версии 1.7, сопоставляют старый и новый языковые коды, сохраняя старые коды
внутри Locale (чтобы getLanguage и toString отражали старый код), но используя новые коды в API
языковых тегов BCP 47 (чтобы toLanguageTag отражал новый). Это сохраняет эквивалентность между
Locales независимо от того, какой код или API используется для их создания. Механизм поиска пакета
ресурсов по умолчанию в Java также реализует это сопоставление, поэтому ресурсы могут быть названы
с использованием любого соглашения, см. ResourceBundle.Control.

*** Трехбуквенный код языка/страны (региона) ***

Конструкторы Locale всегда указывали, что параметры языка и страны имеют длину два символа, хотя на
практике они принимали любую длину. Спецификация теперь смягчена, чтобы разрешить языковые коды от
двух до восьми символов и коды страны (региона) от двух до трех символов, и, в частности, трехбуквенные
коды языков и трехзначные коды регионов, как указано в Реестре языковых подтегов IANA.

Для совместимости реализация по-прежнему не накладывает ограничение на длину.

-------------------------------------------------------------------------------------------

*** Вложенные классы ***

static class Locale.Builder - Builder используется для создания экземпляров Locale из
                              значений, настроенных сеттерами.

static class Locale.Category - Перечисление для категорий локали.

static class Locale.FilteringMode - Это перечисление предоставляет константы для выбора
                                    режима фильтрации для соответствия локали.

static class Locale.LanguageRange - Этот класс выражает языковой диапазон, определенный
                                    в RFC 4647 «Сопоставление языковых тегов».
-------------------------------------------------------------------------------------------

*** Поля ***

static Locale CANADA - константа для страны.
static Locale CANADA_FRENCH - константа для страны.
static Locale CHINA - константа для страны.
static Locale CHINESE - константа для языка.
static Locale ENGLISH - константа для языка.
static Locale FRANCE - константа для страны.
static Locale FRENCH - константа для языка.
static Locale GERMAN - константа для языка.
static Locale GERMANY - константа для страны.
static Locale ITALIAN - константа для языка.
static Locale ITALY - константа для страны.
static Locale JAPAN - константа для языка.
static Locale JAPANESE - константа для языка.
static Locale KOREA - константа для языка.
static Locale KOREAN - константа для языка.
static Locale PRC - константа для языка.
static char	PRIVATE_USE_EXTENSION - Ключ для расширения для частного использования ("x").
static Locale ROOT - константа для корневой локали
static Locale SIMPLIFIED_CHINESE - константа для языка.
static Locale TAIWAN - константа для языка.
static Locale TRADITIONAL_CHINESE - константа для языка.
static Locale UK - константа для языка.
static char	UNICODE_LOCALE_EXTENSION - Ключ для расширения локали Unicode ('u').
static Locale US - константа для языка.
-------------------------------------------------------------------------------------------

*** Конструкторы ***

Locale(String language) - Создайте локаль из кода языка.

Locale(String language,
       String country) - Создайте локаль из языка и страны.

Locale(String language,
       String country,
       String variant) - Создайте языковой стандарт из языка, страны и варианта.
-------------------------------------------------------------------------------------------

*** Методы ***

Object clone() - Переопределяет возможность клонирования.

boolean	equals(Object obj) - Возвращает true, если этот Locale равен другому объекту.

static List<Locale>	filter(List<Locale.LanguageRange> priorityList,
                           Collection<Locale> locales) - Возвращает список совпадающих Locale экземпляров,
                                                         используя механизм фильтрации, определенный в
                                                         RFC 4647.

static List<Locale>	filter(List<Locale.LanguageRange> priorityList,
                           Collection<Locale> locales,
                           Locale.FilteringMode mode) - Возвращает список совпадающих Locale экземпляров,
                                                        используя механизм фильтрации, определенный в
                                                        RFC 4647.

static List<String>	filterTags(List<Locale.LanguageRange> priorityList,
                               Collection<String> tags) - Возвращает список совпадающих языковых тегов,
                                                          используя базовый механизм фильтрации, определенный
                                                          в RFC 4647.

static List<String>	filterTags(List<Locale.LanguageRange> priorityList,
                               Collection<String> tags,
                               Locale.FilteringMode mode) - Возвращает список совпадающих языковых тегов,
                                                            используя базовый механизм фильтрации,
                                                            определенный в RFC 4647.

static Locale forLanguageTag(String languageTag) - Возвращает языковой стандарт для указанной строки
                                                   языкового тега IETF BCP 47.

static Locale[]	getAvailableLocales() - Возвращает массив всех установленных локалей.

String getCountry() - Возвращает код страны/региона для данной локали, который должен быть пустой строкой,
                      двухбуквенным кодом ISO 3166 в верхнем регистре или трехзначным кодом UN M.49.

static Locale getDefault() - Получает текущее значение локали по умолчанию для данного экземпляра
                             виртуальной машины Java.

static Locale getDefault(Locale.Category category) - Получает текущее значение языкового стандарта
                                                     по умолчанию для указанной категории для этого
                                                     экземпляра виртуальной машины Java.

String getDisplayCountry() - Возвращает имя страны региона, подходящее для
                             отображения пользователю.

String getDisplayCountry(Locale inLocale) - Возвращает имя страны региона, подходящее
                                            для отображения пользователю.

String getDisplayLanguage() - Возвращает имя языка локали, подходящее
                              для отображения пользователю.

String getDisplayLanguage(Locale inLocale) - Возвращает имя языка локали, подходящее
                                             для отображения пользователю.

String getDisplayName() - Возвращает имя языкового стандарта, подходящее для
                          отображения пользователю.

String getDisplayName(Locale inLocale) - Возвращает имя языкового стандарта, подходящее
                                         для отображения пользователю.

String getDisplayScript() - Возвращает имя сценария локали, подходящее для
                            отображения пользователю.

String getDisplayScript(Locale inLocale) - Возвращает имя сценария локали, подходящее для
                                           отображения пользователю.

String getDisplayVariant() - Возвращает имя для кода варианта локали, которое подходит для
                             отображения пользователю.

String getDisplayVariant(Locale inLocale) - Возвращает имя для кода варианта локали, которое
                                            подходит для отображения пользователю.

String getExtension(char key) - Возвращает значение расширения (или частного использования),
                                связанное с указанным ключом, или null, если расширение не
                                связано с ключом.

Set<Character> getExtensionKeys() - Возвращает набор ключей расширения, связанных с этой локалью,
                                    или пустой набор, если у него нет расширений.

String getISO3Country() - Возвращает трехбуквенное сокращение для страны этого языкового стандарта.

String getISO3Language() - Возвращает трехбуквенную аббревиатуру языка данной локали.

static String[]	getISOCountries() - Возвращает список всех двухбуквенных кодов стран,
                                    определенных в ISO 3166.

static String[]	getISOLanguages() - Возвращает список всех двухбуквенных кодов языков,
                                    определенных в ISO 639.

String getLanguage() - Возвращает код языка этого Locale.

String getScript() - Возвращает скрипт для этой локали, который должен быть либо пустой строкой,
                     либо 4-буквенным кодом скрипта ISO 15924.

Set<String>	getUnicodeLocaleAttributes() - Возвращает набор атрибутов локали Unicode, связанных
                                           с этой локалью, или пустой набор, если у него нет атрибутов.

Set<String>	getUnicodeLocaleKeys() - Возвращает набор ключей локали Unicode, определенных
                                     этой локалью, или пустой набор, если эта локаль не имеет их.

String getUnicodeLocaleType(String key) - Возвращает тип локали Unicode, связанный с
                                          указанным ключом локали Unicode для этой локали.

String getVariant() - Возвращает код варианта для этой локали.

boolean	hasExtensions() - Возвращает, true если у этого Localeесть какие-либо расширения .

int	hashCode() - Переопределить хэш-код.

static Locale lookup(List<Locale.LanguageRange> priorityList,
                     Collection<Locale> locales) - Возвращает Locale экземпляр наиболее подходящего
                                                   языкового тега, используя механизм поиска, определенный
                                                   в RFC 4647.

static String lookupTag(List<Locale.LanguageRange> priorityList,
                        Collection<String> tags) - Возвращает наиболее подходящий языковой тег, используя
                                                   механизм поиска, определенный в RFC 4647.

static void	setDefault(Locale.Category category,
                       Locale newLocale) - Задает локаль по умолчанию для указанной
                                           категории для этого экземпляра виртуальной
                                           машины Java.

static void	setDefault(Locale newLocale) - Задает локаль по умолчанию для этого экземпляра
                                           виртуальной машины Java.

Locale stripExtensions() - Возвращает копию this Localeбез расширений .

String toLanguageTag() - Возвращает правильно сформированный языковой тег IETF BCP 47, представляющий
                         эту локаль.

String toString() - Возвращает строковое представление этого Locale объекта, состоящее из языка, страны,
                    варианта, скрипта и расширений, как показано ниже: язык + "_" + страна + "_" +
                    (вариант + "_#" | "#") - + скрипт + "-" + расширения Язык всегда указывается в нижнем
                    регистре, страна всегда в верхнем регистре, сценарий всегда в заголовке, а расширения
                    всегда в нижнем регистре.

************************************************************************************************************
См. более подробно: https://docs.oracle.com/javase/8/docs/api/java/util/Locale.html
************************************************************************************************************