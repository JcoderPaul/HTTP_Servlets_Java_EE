****** Model-View-Controller ******

Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема
разделения данных приложения и управляющей логики на три отдельных компонента (уровня): модель,
представление и контроллер — таким образом, что модификация каждого компонента может осуществляться
независимо.

Модель (Model) - предоставляет данные и реагирует на команды контроллера, изменяя своё состояние.
                 Модель ничего не знает ни о Виде, ни о Контроллере, что делает возможным ее
                 разработку и тестирование как независимого компонента. И это является главным
                 моментом MVC. Модель, может быть "Пассивной" либо "Активной".

                 "Пассивная Модель" никак не воздействует ни на "Вид" ни на "Контроллер". В этом
                 случае все изменения "Модели" отслеживаются "Контроллером" и он же отвечает за
                 перерисовку "Вида", когда это необходимо.

                 Но обычно, под MVC все таки подразумевают вариант с "Активной Моделью".

                 «Активная Модель» оповещает о том, что в ней произошли изменения. И делает она это
                 посредством шаблона "Наблюдатель", рассылая уведомления об изменениях всем своим
                 «подписчикам». «Активный Вид» подписывается на эти сообщения сам и таким образом
                 знает когда нужно заново считать из модели нужные ему данные и обновиться. В случае
                 «Пассивного Вида», подписчиком является "Контроллер", который уже затем обновляет "Вид".

                 Шаблон "Наблюдатель" позволяет "Модели" с одной стороны информировать "Вид" или
                 "Контроллер" о том, что в ней произошли изменения, а с другой, фактически, ничего о
                 них «не знать» (кроме того, что они реализуют некий заданный интерфейс «подписчика»)
                 и тем самым оставаться независимой. Это называется слабым связыванием и считается
                 вторым ключевым моментом MVC.

                 Именно поэтому, когда говорится, что MVC это составной шаблон, то в первую очередь в
                 качестве одного из его компонентов упоминается паттерн "Наблюдатель". На диаграммах
                 слабое связывание принято рисовать пунктирной стрелкой, но многие это правило игнорируют.

Представление, Вид (View) - отвечает за отображение данных модели пользователю, реагируя на изменения модели.
                            "Вид" отображает "Модель". И значит, он каким-то образом должен получать из нее
                            нужные для отображения данные. Наиболее распространены следующие два варианта:
                            1) "Активный Вид", который знает о Модели и сам берет из нее нужные данные.
                            2) "Пассивный Вид", которому данные поставляет Контроллер. В этом случае Вид
                               с Моделью никак не связан.

                            Видов может быть несколько — они могут по-разному отображать одни и те же
                            данные, например в виде таблицы или графика, или же отвечать за отображение
                            разных частей данных из Модели.

Контроллер (Controller) - интерпретирует действия пользователя, оповещая модель о необходимости изменений.
                          Контроллер является самым неоднозначным компонентом. Тем не менее общим является то,
                          что Контроллер всегда знает о Модели и может ее изменять (как правило, в результате
                          действий пользователя).

                          А также он может осуществлять управление Видом/Видами (особенно если их несколько) и
                          соответственно знать о Видах, но это не обязательно.

MVC это прежде всего набор архитектурных идей/принципов/подходов, которые могут быть реализованы различными
способами с использованием различных шаблонов. MVC, в любой своей разновидности, это прежде всего набор
архитектурных принципов для разработки приложений с пользовательским интерфейсом и его главное назначение –
обеспечить взаимодействие приложения с пользователем. Поэтому в полноценной MVC схеме (явно или неявно) должен
присутствовать пользователь.

И тут в основном встречаются две трактовки:

1. Пользователь управляет приложением через "Контроллер", а "Вид" служит исключительно для отображения информации
о "Модели", и пользователь его лишь видит. Часто указывают лишь то, что пользователь действует на "Контроллер",
а то что он видит "Вид" не указывают.

2. Пользователь взаимодействует только с "Видом". То есть "Вид" не только отражает "Модель", но также принимает
команды пользователя и передает их "Контроллеру". В этом случае между "Видом" и "Контроллером" образуется еще одна
связь: прямая ("Вид" знает о "Контроллере" и напрямую передает информацию) или, чаще всего, ослабленная ("Вид"
просто рассылает информацию о действиях пользователя всем заинтересованным подписчикам, а "Контроллер" на эту
рассылку подписывается)

Вариант с "Пассивным Видом", когда "Вид" никак не связан с "Моделью" и данные для отображения ему поставляет
"Контроллер", иногда называют MVC, а иногда выделяют в отдельную разновидность — MVP и тогда "Контроллер"
переименовывают в "Презентер".

****** «Трехуровневый MVC» в WEB-Разработке ******

MVC получил самое широкое распространение, и поэтому в нем максимально отразились свойственные веб-программированию
черты. А именно, привязка к трехуровневой архитектуре "клиент–сервер–база данных" и преобладание скриптовых языков.
В результате компоненты MVC формально привязываются к трем слоям архитектуры и получается что:

- Модель = База Данных: Модель — это просто данные, которыми оперирует приложение.
- Контроллер = Сервер: Контроллер — это бизнес-логика приложения. Иногда еще говорят что контроллер это центр
                       обработки всех запросов и принятия решений, а также промежуточный слой обеспечивающий
                       связь модели и представления.
- Вид = Клиент: Вид — это пользовательский интерфейс. Причем интерфейс в этом случае, как правило, понимается в
                основном исключительно как «дизайн», просто набор графических элементов. Логика же работы этого
                интерфейса, как и логика работы с данными, выносится в "Контроллер".

Про неадекватность этого подхода написано уже так много, что это вошло даже в википедию:

Начинающие программисты очень часто трактуют архитектурную модель MVC как пассивную модель MVC: модель выступает
исключительно совокупностью функций для доступа к данным, а контроллер содержит бизнес-логику. В результате — код
моделей по факту является средством получения данных из СУБД, а контроллер — типичным модулем, наполненным
бизнес-логикой.

В результате такого понимания — MVC-разработчики стали писать код, который Падриг Брэди (известный в кругах
сообщества «Zend Framework») охарактеризовал как «ТТУК» («Толстые, тупые, уродливые контроллеры» или
Fat Stupid Ugly Controllers): - "Среднестатистический ТТУК получал данные из БД (используя уровень абстракции
базы данных, делая вид, что это модель) или манипулировал, проверял, записывал, а также передавал данные в
"Вид" или "Представление". Такой подход стал очень популярен потому, что использование таких контроллеров похоже
на классическую практику использования отдельного php-файла для каждой страницы приложения."

Но в объектно-ориентированном программировании используется активная модель MVC, где "Модель" — это не только
совокупность кода доступа к данным и СУБД, но и вся бизнес-логика; также "Модели" могут инкапсулировать в себе
другие "Модели". Контроллеры — как элементы информационной системы, — ответственны лишь за:

- приём запроса от пользователя;
- анализ запроса;
- выбор следующего действия системы, соответственно результатам анализа (например, передача запроса другим
  элементам системы).

Только в этом случае "Контроллер" становится "тонким" и выполняет исключительно функцию связующего звена
(glue layer) между отдельными компонентами информационной системы.

Основные выводы из выше сказанного:

1. Независимость "Модели" является главным в MVC. Если "Модель" тонкая, то есть содержит лишь данные, то
   возможность ее независимой разработки имеет мало смысла. Соответственно при таком подходе теряет смысл
   и сам MVC

2. Вся бизнес-логика приложения, то есть большая часть кода, сосредотачивается в "Контроллере" и это при том,
   что как раз "Контроллер" является самой зависимой частью в MVC – в общем случае он зависит и от Модели и
   от Вида.

   Вообще говоря в хорошо спроектированных приложениях стараются делать с точностью до наоборот – наиболее
   зависимые части должны быть минимальными, а не максимальными.

3. На практике "Контроллеру" в веб-приложении обычно соответствует один скрипт и вынесение всей бизнес-логики
   в "Контроллер" фактически означает еще и то, что большая часть приложения оказывается в одном скрипте.
   Отсюда и появился термин ТТУК — толстый тупой уродливый контроллер.

4. Поскольку, как правило, тонкой является не только "Модель", но и "Вид" (тупой Вид или тупой интерфейс — Dumb GUI,
   Dumb View), то, как следствие, в "Контроллер" помимо всей бизнес-логики приложения помещается также еще и логика
   управления пользовательским интерфейсом. То есть, вместо разделения бизнес логики и логики представления при
   таком подходе получается их смешение. См. Wrong WEB-MVC.png

Программа, конечно, разбивается на множество MVC, соответствующих страницам веб-приложения, и это спасает ситуацию,
но, увы, не меняет сути.

!!! Переплетения в "Контроллере" бизнесс-логики и GUI-логики необходимо избегать !!!

в объектно-ориентированном приложении нет данных, а есть множество объектов и каждый из них содержит какие-то
данные и методы работы с ними. В том числе и объекты доступа к базе данных (если они имеются). Поэтому когда
определение "Модели" начинается со слова "данные", то оно в сущности имеет мало смысла и в завуалированной форме
подразумевает все тот же самый доступ к базе данных. В обработку же действий пользователя нередко помещается
львиная доля бизнес-логики и в результате по-прежнему вся, или почти вся, логика приложения часто оказывается
в "Контроллере".

****** «Архитектурный MVC» ******

Мартин Фаулер (https://martinfowler.com/) говорит, что MVC это не паттерн, а набор архитектурных принципов и идей,
используемых при построении пользовательских информационных систем (как правило сложных).

Если же говорить предельно кратко, то суть состоит в следующем:
- сложную систему нужно разбивать на модули. Причем декомпозицию желательно делать иерархически, а модули,
  на которые разбивается система, должны быть, по возможности, независимы или слабо связаны (Low coupling).
  Чем слабее связанность, тем легче писать/понимать/расширять/чинить программу.

  Поэтому одной из основных задач при декомпозиции является минимизация и ослабление связей между компонентами.

Давайте посмотрим, как эти принципы применяются в MVC для создания первичной архитектуры (декомпозиции)
пользовательских приложений. По сути в основе MVC лежат три довольно простые идеи:
-----------------------------------------------------------------------------------------------------------------

*** 1 *** Отделение модели предметной области (бизнес логики) приложения от пользовательского интерфейса ***

Первая и основная идея MVC заключается в том, что любое пользовательское приложение в первом приближении
можно разделить на два модуля — один из которых обеспечивает основной функционал приложения, его бизнес-логику,
а второй отвечает за взаимодействие с пользователем см. Decomposition_step_one.png

Тем самым мы получаем возможность разрабатывать модель предметной области, содержащую бизнес-логику системы и
составляющую функциональное ядро приложения, не думая о том как именно она будет взаимодействовать с пользователем.

Задача же взаимодействия с пользователем выносится в отдельный модуль – "пользовательский интерфейс" и тоже может
решаться относительно независимо.

Именно модель предметной области ("Доменная Модель" от английского "domain model") считается "Моделью" в
«архитектурном MVC» (отсюда и термин). Поэтому так важно чтобы она была независимой и могла независимо
разрабатываться и тестироваться.

"Сердцевиной идеей MVC, как и основной идеей для всех последующих каркасов, является то, что я называю
«отделенное представление» (Separated Presentation). Смысл отделенного представления в том, чтобы провести
четкую границу между доменными объектами, которые отражают наш реальный мир, и объектами представления,
которыми являются GUI-элементы на экране. Доменные объекты должны быть полностью независимы и работать без
ссылок на представление, они должны обладать возможностью поддерживать (support) множественные представления,
возможно даже одновременно. Этот подход, кстати, так же был одним из важных аспектов Unix-культуры,
позволяющий даже сегодня работать во множестве приложений как через командную строку, так и через графический
интерфейс (одновременно)." — Мартин Фаулер

*** 2 *** Независимость "Модели" и синхронизация пользовательских интерфейсов за счет шаблона "Наблюдатель" ***

Вторая ключевая идея заключается в том, что для того, чтобы иметь возможность разрабатывать "Модель" независимо,
необходимо ослабить ее зависимость от пользовательского интерфейса. И делается это, как уже упоминалось выше, за
счет шаблона "Наблюдатель".

"Модель" рассылает извещения об изменениях. "Интерфейс" подписывается на эти оповещения и таким образом знает,
когда нужно заново считать данные из модели и обновиться. Благодаря этому мы получаем практически независимую
"Модель", которая ничего не знает о связанных с ней пользовательских интерфейсах, кроме того что они реализуют
интерфейс «наблюдателя».

*** 3 *** Разделение Пользовательского Интерфейса на "Вид" и "Контроллер" ***

Третья идея это просто второй шаг иерархической декомпозиции. После первичного разделения приложения на
бизнес-модель и интерфейс, декомпозиция продолжается на следующем иерархическом уровне и уже пользовательский
интерфейс, в свою очередь, делится на "Вид" и "Контроллер", см. Decomposition_step_two.png

-----------------------------------------------------------------------------------------------------------------

Поскольку деление пользовательского интерфейса на "Вид" и "Контроллер" относится ко второму уровню иерархии,
оно гораздо менее значимо чем первичное разделения приложения на доменную модель и интерфейс. Очень часто
(особенно когда дело касается простых виджетов) оно вообще не делается и используется «упрощенный MVC», в
котором имеется только "Модель" и единый UI-компонент, представляющий собой объединенный "Вид-Контроллер".

«Архитектурный MVC» на первый взгляд выглядит вполне разумно. Но как только мы попытаемся применить его не
к учебному примеру из трех классов, а к реальной программе, то столкнемся с целым рядом проблем и вопросов,
о которых редко пишут, но которые чрезвычайно важны. И касаются они не только пользовательского интерфейса,
но и самой "Модели".

Все же предлагаю попробовать с ними разобраться, то есть обратиться к первоисточникам.

****** «Original MVC» ******

Мы привыкли к тому, что MVC почти всегда рассматривается на примере создания какого нибудь простейшего
графического компонента, вся «бизнес логика» которого помещается в один класс с данными и парой методов
для их изменения. Но что делать, когда речь идет о реальных приложениях, ядро которых состоит из многих
взаимосвязанных объектов работающих совместно?

Вариант первый - "Модель" реализует шаблон "Наблюдатель" и это явно указывает на то, что "Модель" это именно
                 один объект. На это же указывает и то, что "Вид" и "Контроллер" должны знать о "Модели" (для
                 того чтобы брать из нее данные и вносить изменения) следовательно, они должны содержать на
                 нее ссылку.

                 Но тогда, если считать, что под "Моделью" подразумевается "доменная модель", мы вновь приходим
                 к тому что все ядро приложения оказывается в одном объекте. Только теперь вместо толстого
                 уродливого "Контроллера", у нас появляется толстая "Модель". Толстая "Модель" конечно лучше,
                 поскольку она независима и в ней, по крайней мере, не смешивается бизнес-логика с логикой GUI,
                 но все равно такое решение сложно отнести к хорошей архитектуре.

Вариант второй - "Модель" это множество доменных объектов, совместно реализующих бизнес-логику.

                 Тогда остается открытым вопрос – кто реализует шаблон "Наблюдатель", откуда берет данные "Вид",
                 куда передает команды пользователя "Контроллер"?

                 Тут можно сказать лишь одно: архитектура, в которой модули ("Вид" или "Контроллер"), должены «лезть»
                 внутрь другого модуля (доменной модели) и искать там для себя данные или объекты для изменения очень
                 плоха!

                 Получается что "Вид" и "Контроллер" зависят от деталей реализации "доменной модели", и если структура
                 этой самой модели изменится, то придется переделывать весь пользовательский интерфейс.

Придется вновь обратиться к исходным принципам MVC:

Когда говорилось о том, что систему надо разбивать на модули, слабо связанные друг с другом, мы не упомянули главное
правило, позволяющее добится этой самой слабой связанности:
– модули друг для друга должны быть «черными ящиками». Ни при каких условиях один модуль не должен обращаться к
  объектам другого модуля напрямую и что-либо знать о его внутренней структуре.
- модули должны взаимодействовать друг с другом лишь на уровне абстрактных интерфейсов (Dependency Inversion
  Principle). А реализует интерфейс модуля как правило специальный объект — "Фасад".

И если поискать какие же паттерны позволяют добится слабой связанности, то на первом месте будет находиться именно
паттерн "Фасад", и только затем "Наблюдатель" и т.д.

Таким образом, ключевая идея MVC действительно состоит в том, что пользовательское приложение делится на два
модуля:
– один из которых моделирует предметную область и реализует бизнес логику (доменная модель);
- второй отвечает за взаимодействие с пользователем (пользовательский интерфейс).

Но при этом "Модель" в «MVC схеме» вовсе не тождественна доменной модели (которая может быть сколь угодно сложной
и состоять из множества объектов), а является всего лишь ее интерфейсом и фасадом.

При этом ни "Вид" ни "Контроллер" не должны знать о том, как устроен модуль предметной области (доменная модель),
где и в каком формате там храняться данные, и как именно осуществляется управление. Они взаимодействуют лишь с
интерфейсом и реализующим его объектом-фасадом, который предоставляет все нужные данные в нужном формате и удобный
набор высокоуровневых команд для управления подсистемой, а также реализует шаблон "Наблюдатель", для извещения о
значимых изменениях в подсистеме. И если мы захотим поменять базу данных, использовать облако, или вообще собирать
нужные нам данные из различных источников в сети, если внесем какие угодно изменения в бизнес логику приложения,
но при этом оставим неизменным интерфейс-фасад, то ни "Вид", ни "Контроллер" это никак не затронет.

Мы имеем архитектуру устойчивую к изменениям. И тогда схема MVC, будет выглядеть следующим образом:
см. Domain_model_scheme_MVC.png

Давайте рассмотрим данную схему подробнее. Традиционно в клиент-серверных приложениях главным считается сервер.
Он предоставляет услуги/сервисы и решает в каком виде это должно быть реализовано. Соответственно интерфейс и
фасад, как правило, определяются с точки зрения сервера. А клиенты под этот заданный формат подстраиваются.

На практике же более адекватной оказывается не сервер-ориентированная архитектура, а клиент-ориентированная.
В ней фокус с сервера смещается в сторону клиента и интерфейс, вернее интерфейсы (и фасад или фасады), определяются
исходя из потребностей клиентов. Вместо "Предоставляемого Интерфейса" (Provided Interface) используются
"Требуемые Интерфейсы" (RequiredInterface), см. Model_scheme_MVC_1.png или Model_scheme_MVC_2.png

Клиент ориентированный подход гораздо лучше соответствует "Принципу разделения интерфейсов" (Interface Segregation
Principle) поскольку в нем вместо единого для всех толстого ProvidedInterface используется множество тонких
RequiredInterface.

"Фасад" - тот самый клей (glue), объект посредник, прокси, фильтр, адаптер и т.д., связывающий между собой
доменную модель и пользовательский интерфейс и поставляющий нужные данные в нужном/удобном формате.

!!! Из-за того, что разработчики не всегда хорошо понимают что стоит за всеми этими «моделями», а сами модели
привыкли воспринимать как данные, а не интерфейс, то это становится источником еще одной весьма распространенной
и ресурсоемкой ошибки. Вместо того чтобы нужным образом всего лишь интерпретировать и адаптировать имеющиеся
доменные данные с помощью моделей-посредников их начинают копировать в эти модели-посредники. !!!

*******************************************************************************************************************
Оригинал статьи: https://habr.com/ru/articles/321050/
                 https://ru.wikipedia.org/wiki/Model-View-Controller
                 https://javarush.com/groups/posts/2536-chastjh-7-znakomstvo-s-patternom-mvc-model-view-controller
*******************************************************************************************************************